# Copyright 2017 Google LLC. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

def compile_grm(
        name,
        src = None,
        out = None,
        data = [],
        _compiler = "@org_opengrm_thrax//:compiler"
):
    """Compile a Thrax grm file to a FAR file.

    Note that if src depends on other this target needs to include *both* the
    compile_grm target for it and the .grm file.
    """

    # Rather than invoking the Thrax compiler directly in a genrule, we go via an
    # intermediate sh_binary. The reason for this is that, unlike a genrule, an
    # sh_binary as a runfiles directory in which all runtime dependencies are
    # present as symlinks in a predictable directory layout. This allows the Thrax
    # compiler to read additional runtime data (e.g. symbol tables) from
    # predictable relative paths, regardless of whether they were present in the
    # source tree or generated by build rules.
    suffix = ".grm"
    if not name:
        fail("Ill-formed src name: " + src)
    if not out:
        out = src[:-len(suffix)] + ".far"
    genrule_name = "compile_%s_grm" % name
    tool_name = genrule_name + "_helper"
    data = [d for d in data if d != src]
    native.sh_binary(
        name = tool_name,
        srcs = ["@com_gitlab_tiro_is_tiro_speech_core//tools/thrax:compile_grm_helper.sh"],
        data = data + [
            src,
            _compiler,
        ],
    )
    native.genrule(
        name = name,
        srcs = [src],
        outs = [out],
        cmd = "$(location {tool_name}) $< $@".format(
            tool_name = tool_name,
            compiler = _compiler
        ),
        tools = [tool_name],
    )

def grm_export_fsts(
        name,
        src = None,
        rules = [],
        visibility = None,
        _farextract = "@openfst//:farextract",
):
    """Export FSTs, i.e. rules, from FARs"""
    if not src:
        fail("No source FAR specified.")
    if not rules:
        fail("No rules specified for export.")

    rules_out_suffix = ".fst"
    native.genrule(
        name = name,
        srcs = [src],
        outs = [r + rules_out_suffix for r in rules],
        cmd = """\
        $(location {farextract}) --filename_prefix=$(RULEDIR)/ \
                                 --filename_suffix={suffix} \
                                 --keys={rules}  $<
        """.format(
            farextract = _farextract,
            rules = ",".join(rules),
            suffix = rules_out_suffix,
        ),
        tools = [_farextract],
        visibility = visibility,
    )


# # This does not work (generated FARs not in proper location in tree):
# GrmInfo = provider(
#     fields = {
#         "transitive_sources": "depset of GRM Files",
#     },
# )

# def _grm_library_impl(ctx):
#     if len(ctx.attr.srcs) > 1:
#         fail("Only one main .grm, specify imported .grm files as dependencies")

#     srcs = ctx.files.srcs
#     input_grammar = srcs[0]
#     transitive_fars = [dep[DefaultInfo].files for dep in ctx.attr.deps]
#     transitive_grms = [dep[GrmInfo].transitive_sources for dep in ctx.attr.deps]

#     output_far = ctx.actions.declare_file(
#         ctx.label.name + ".far",
#         sibling = input_grammar,
#     )

#     roots = []
#     for dep in transitive_fars:
#         for f in dep.to_list():
#             roots.append(f.root)

#     inputs = depset(srcs, transitive=transitive_fars + transitive_grms)

#     args = ctx.actions.args()
#     args.add("--input_grammar=" + input_grammar.path)
#     args.add("--output_far=" + output_far.path)

#     far_files = []
#     for dep in transitive_fars:
#         far_files += dep.to_list()


#     print("FAR_FILES", far_files)
#     for far in far_files:
#         print(far.path)

#     ctx.actions.run(
#         mnemonic = "GrmCompile",
#         inputs = inputs,
#         outputs = [output_far],
#         # command = ctx.executable._compiler.path + "%s" % args,
#         executable = ctx.executable._compiler,
#         tools = far_files,
#         arguments = [args],
#     )

#     print(transitive_fars)

#     runfiles = ctx.runfiles(files=[output_far])
#     for dep in ctx.attr.deps:
#         runfiles = runfiles.merge(dep[DefaultInfo].default_runfiles)

#     transitive_sources = depset(
#         srcs,
#         transitive = [dep[GrmInfo].transitive_sources for dep in ctx.attr.deps],
#     )

#     info = GrmInfo(transitive_sources = transitive_sources)

#     return [
#         DefaultInfo(
#             files = depset([output_far],
#                            transitive = transitive_fars),
#             default_runfiles = runfiles
#         ),
#         info,
#     ]

# grm_library = rule(
#     implementation = _grm_library_impl,
#     attrs = {
#         "srcs": attr.label_list(
#             allow_files = [".grm"],
#         ),
#         "deps": attr.label_list(
#             allow_empty = True,
#             providers = [GrmInfo],
#         ),
#         "_compiler": attr.label(
#             default = Label("@org_opengrm_thrax//:compiler"),
#             allow_single_file = True,
#             executable = True,
#             cfg = "exec",
#         ),
#     },
#     provides = [DefaultInfo, GrmInfo],
# )
